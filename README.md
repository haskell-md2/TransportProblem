# TransportProblem

Это отличная тема для курсового или лабораторного проекта. Чтобы три человека писали на C++ и не мешали друг другу, нужно разделить проект по принципу **«Интерфейс — Реализация — Расширение»**.

Главный секрет успеха в командной разработке на C++ — заранее договориться о структуре данных (классе или структуре), которая будет передаваться между модулями.

Вот предложение по разбиению задач.

### Общая база (Договориться в начале)
Перед началом работы создайте один заголовочный файл `TransportationData.h`. В нем опишите структуру, которую будут использовать все трое.

```cpp
// TransportationData.h
#include <vector>
#include <iostream>

struct ProblemData {
    int numSuppliers; // 5
    int numConsumers; // 5
    std::vector<int> supply; // Запасы поставщиков
    std::vector<int> demand; // Потребности потребителей
    std::vector<std::vector<double>> costs; // Матрица стоимостей
};

// Абстрактный класс (интерфейс) для солвера
class ISolver {
public:
    virtual void solve(ProblemData data) = 0;
    virtual ~ISolver() = default;
};
```

***

### Участник №1: Классика и Визуализация (Метод потенциалов)
**Задача:** Реализовать «классический» путь решения транспортной задачи. Этот модуль будет отвечать за логику перераспределения грузов в таблице.

**Фронт работ:**
1.  **Начальное решение:** Реализовать метод Северо-Западного угла (СЗ).
2.  **Оптимизация:** Реализовать Метод Потенциалов. Нужно написать функцию поиска $u_i$ и $v_j$, вычисления оценок свободных клеток и нахождения цикла.
3.  **Визуализация цикла:** Это самая творческая часть задачи.
    *   *Требование:* «Вывод циклов пересчетов человечески».
    *   *Реализация:* Написать функцию, которая принимает список координат цикла (например, `[(1,1), (1,3), (2,3), (2,1)]`) и рисует его в консоли не просто списком, а показывает знаки $(+ - + -)$.
    *   *«На прямой»:* Развернуть цикл в строку вида: `S1->D1(+) == S1->D3(-) == S2->D3(+) == S2->D1(-)`.

**Файлы:** `ClassicSolver.h`, `ClassicSolver.cpp`

***

### Участник №2: Альтернативный подход (Симплекс-метод)
**Задача:** Решить ту же задачу, но совершенно другим математическим аппаратом. Это гарантирует независимость разработки, так как алгоритм не пересекается с участником №1.

**Фронт работ:**
1.  **Сведение к ЗЛП:** Написать конвертер, который превращает матрицу $5 \times 5$ в систему линейных ограничений $Ax = b$.
    *   Переменных будет $25$ ($x_{11} \dots x_{55}$).
    *   Ограничений будет $10$ ($5$ по строкам + $5$ по столбцам).
2.  **Реализация Симплекса:** Написать (или адаптировать готовый) табличный симплекс-метод.
3.  **Сравнение:** Вывести итоговую стоимость перевозки. Она должна совпасть с ответом Участника №1 (это будет отличным способом проверки правильности работы всей команды).

**Файлы:** `SimplexSolver.h`, `SimplexSolver.cpp`

***

### Участник №3: Архитектор и Усложнение (Штрафы и Моделирование)
**Задача:** Этот участник создает саму задачу (данные), связывает работу первых двух участников и реализует «бизнес-логику» со штрафами. Ему не нужно писать алгоритмы решения, ему нужно *подготовить данные* так, чтобы алгоритмы их «съели».

**Фронт работ:**
1.  **Генерация данных:** Придумать и захардкодить (или считать из файла) конкретный пример $5 \times 5$.
2.  **Логика штрафов (Усложнение):**
    *   *Математика:* Штраф за недопоставку начиная с определенного уровня для одного потребителя реализуется через **расщепление столбца потребителя**.
    *   *Пример:* Потребителю №3 нужно 20 единиц. Штраф вводится, если мы не поставили хотя бы 10. Участник №3 должен написать код, который берет исходную матрицу $5 \times 5$ и превращает её в $5 \times 6$:
        *   Столбец $D_3'$ (первые 10 единиц, обычная цена).
        *   Столбец $D_3''$ (оставшиеся 10 единиц, цена + штраф).
3.  **Оркестрация (`main.cpp`):**
    *   Создать объект `ProblemData`.
    *   Вызвать код Участника №1 (обычное решение).
    *   Вызвать код Участника №2 (симплекс).
    *   Применить модификацию со штрафом (изменить `ProblemData`) и снова скормить её Участнику №1.

**Файлы:** `main.cpp`, `PenaltyManager.h`

***

### Пример задачи (для старта)

Чтобы не тратить время на придумывание цифр, возьмите этот сбалансированный пример:

**Поставщики (Запасы):** `[20, 30, 15, 10, 25]` (Сумма: 100)
**Потребители (Спрос):** `[10, 20, 30, 15, 25]` (Сумма: 100)

**Матрица стоимостей (5x5):**
$$
\begin{pmatrix}
5 & 3 & 6 & 2 & 4 \\
4 & 7 & 9 & 1 & 5 \\
3 & 4 & 5 & 2 & 8 \\
2 & 6 & 3 & 5 & 1 \\
8 & 2 & 4 & 6 & 3
\end{pmatrix}
$$

### Как описать алгоритм цикла пересчета «на прямой» (Для Участника №1)

Обычно цикл рисуют в таблице стрелочками. «На прямой» означает линеаризацию графа.

1.  **Найти цикл:** Допустим, мы вводим перевозку в клетку $(1, 3)$. Система находит замкнутый контур по занятым клеткам: $(1,3) \to (1,1) \to (2,1) \to (2,3) \to (1,3)$.
2.  **Визуализация на прямой:**
    Вы выводите это как цепочку обменов:
    `Вводим (Пост1, Потр3) [+] -> Забираем у (Пост1, Потр1) [-] -> Добавляем (Пост2, Потр1) [+] -> Забираем у (Пост2, Потр3) [-]`

Это наглядно показывает баланс: сколько взяли, столько и отдали, сумма по строкам и столбцам не нарушилась.